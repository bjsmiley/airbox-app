use std::{fmt, net::Ipv4Addr, ops::Deref};

use rcgen::{CertificateParams, DistinguishedName, DnType, SanType};
use ring::digest::digest;
use serde::{Deserialize, Serialize};

use crate::err::IdError;

/// is a unique identifier for a peer. These are derived from the public key of the peer.
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Serialize, Deserialize)]
#[repr(C)]
pub struct PeerId(String);

impl PeerId {
    /// from_str attempts to load a Public Id from a string. It will return an error if the PeerId is invalid.
    pub fn from_string(id: String) -> Result<PeerId, IdError> {
        if id.len() != 40 {
            return Err(IdError::Length);
        } else if !id.chars().all(char::is_alphanumeric) {
            return Err(IdError::InvalidCharacters);
        }
        Ok(Self(id))
    }

    /// from_cert will derive a [PeerId] from a [rustls::Certificate].
    pub fn from_cert(cert: &rustls::Certificate) -> Self {
        // SHA-1 is used due to the limitation of the length of a DNS record used for mDNS local network discovery.
        let peer_id = digest(&ring::digest::SHA256, &cert.0)
            .as_ref()
            .iter()
            .map(|b| format!("{b:02x}"))
            .collect();

        Self(peer_id)
    }

    pub fn inner(&self) -> &String {
        &self.0
    }
}

impl PartialEq<PeerId> for &PeerId {
    fn eq(&self, other: &PeerId) -> bool {
        self.0 == other.0
    }
}

impl fmt::Display for PeerId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl Deref for PeerId {
    type Target = String;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl Default for PeerId {
    fn default() -> Self {
        Self(String::from("0000000000000000000000000000000000000000"))
    }
}

/// The common name of the identity certificate generated by fd-cdp.
const CERTIFICATE_COMMON_NAME: &str = "fd-p2p-identity";

/// Is the identity which respresents the current peer. An Identity is made from a public key and a private key combo. [crate::PeerId]'s are derived from the public key portion of a peer's [Identity].
/// The public key is safe to share while the private key must remain private to ensure the connections between peers are secure.
#[derive(Clone, Serialize, Deserialize)]
pub struct Identity {
    certificate: Vec<u8>,
    private_key: Vec<u8>,
}

impl Identity {
    /// Create a new Identity for the current peer.
    pub fn new() -> Self {
        let mut parameters: CertificateParams = Default::default();
        parameters.distinguished_name = DistinguishedName::new();
        parameters
            .distinguished_name
            .push(DnType::CommonName, CERTIFICATE_COMMON_NAME);
        parameters.subject_alt_names = vec![SanType::IpAddress(Ipv4Addr::LOCALHOST.into())];

        let cert = rcgen::Certificate::from_params(parameters).unwrap();

        Self {
            certificate: cert.serialize_der().unwrap(),
            private_key: cert.serialize_private_key_der(),
        }
    }

    /// Load the current identity from it's raw form.
    pub fn from_raw(certificate: Vec<u8>, private_key: Vec<u8>) -> Self {
        Self {
            certificate,
            private_key,
        }
    }

    /// Convert this identity into it's raw form so it can be saved.
    pub fn to_raw(&self) -> (Vec<u8>, Vec<u8>) {
        (self.certificate.clone(), self.private_key.clone())
    }

    /// Convert this identity into rustls compatible form so it can be used for the QUIC TLS handshake.
    pub fn into_rustls(self) -> (rustls::Certificate, rustls::PrivateKey) {
        (
            rustls::Certificate(self.certificate),
            rustls::PrivateKey(self.private_key),
        )
    }
}
